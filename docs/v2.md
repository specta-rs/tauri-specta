# Tauri Specta v2

### Installation

> [!WARNING]  
> Tauri Specta v2 is still in beta, until Tauri v2 lands as stable.
> 
> However, it's safe to use as long as you lock your versions.

> [!WARNING]  
> Until [tauri-apps/tauri #9392](https://github.com/tauri-apps/tauri/pull/9392) is released, you must use the following in your `Cargo.toml` (if your using a Cargo workspace use the root `Cargo.toml`):
> ```toml
> [patch.crates-io]
> tauri = { git = "https://github.com/tauri-apps/tauri", rev = "3f0805488506e013e15cfb3cc1cfc8c2c5f84bd2" }
> tauri-specta = { git = "https://github.com/oscartbeaumont/tauri-specta", rev = "10ceb8716def4c7337e36ed8b8d974c1aefd4aab" }
> ```

```bash
cargo add tauri@=2.0.0-beta.16
cargo add specta@=2.0.0-rc.11
cargo add tauri-specta@=2.0.0-rc.4 --features javascript,typescript
```

## Adding Specta to custom types

```rust
use specta::Type;
use serde::{Deserialize, Serialize};

// The `specta::Type` macro allows us to understand your types
// We implement `specta::Type` on primitive types for you.
// If you want to use a type from an external crate you may need to enable the feature on Specta.
#[derive(Serialize, Type)]
pub struct MyCustomReturnType {
    pub some_field: String,
}

#[derive(Deserialize, Type)]
pub struct MyCustomArgumentType {
    pub foo: String,
    pub bar: i32,
}
```

## Annotate your Tauri commands with Specta

```rust
#[tauri::command]
#[specta::specta] // <-- This bit here
fn greet3() -> MyCustomReturnType {
    MyCustomReturnType {
        some_field: "Hello World".into(),
    }
}

#[tauri::command]
#[specta::specta] // <-- This bit here
fn greet(name: String) -> String {
  format!("Hello {name}!")
}
```

## Export your bindings

```rust
use specta::collect_types;
use tauri_specta::{ts, js};

// this example exports your types on startup when in debug mode. You can do whatever.

fn main() {
    let specta_builder = {
        // You can use `tauri_specta::js::builder` for exporting JS Doc instead of Typescript!`
        let specta_builder = tauri_specta::ts::builder()
            .commands(tauri_specta::collect_commands![greet, greet2, greet3 ]); // <- Each of your comments


        #[cfg(debug_assertions)] // <- Only export on non-release builds
        let specta_builder = specta_builder.path("../src/bindings.ts");

        specta_builder.into_plugin()
    };

    tauri::Builder::default()
        .plugin(specta_builder)
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

## Usage on frontend

```ts
import * as commands from "./bindings"; // This should point to the file we export from Rust

await commands.greet("Brendan");
```

## Events

Firstly you have to define your event types. You can add as many of these as you want.

```rust
#[derive(Debug, Clone, Serialize, Deserialize, specta::Type, tauri_specta::Event)]
pub struct DemoEvent(String);
```

Next you must add it to the builder like the following:

```rust
let specta_builder = ts::builder()
        .events(tauri_specta::collect_events![DemoEvent]); // This should contain all your events.
```

Then it can be used in Rust like the following:

```rust
tauri::Builder::default()
    .setup(|app| {
        let handle = app.handle();

        DemoEvent::listen_global(&handle, |event| {
            dbg!(event.payload);
        });

        DemoEvent("Test".to_string()).emit_all(&handle).unwrap();
    });
```

and it can be used in TS like the following:

```ts
import { commands, events } from "./bindings";
import { appWindow } from "@tauri-apps/api/window";

// For all windows
events.demoEvent.listen((e) => console.log(e));

// For a single window
events.demoEvent(appWindow).listen((e) => console.log(e));

// Emit to the backend and all windows
await events.demoEvent.emit("Test")

// Emit to a window
await events.demoEvent(appWindow).emit("Test")
```
