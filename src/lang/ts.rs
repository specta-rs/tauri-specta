use crate::{
    ErrorHandlingMode, ExportContext, ItemType, LanguageExt, apply_as_prefix, lang::js_ts,
};
use heck::ToLowerCamelCase;
use specta::datatype::{Function, FunctionReturnType};
use specta_typescript::{self as ts, Typescript, primitives};

const GLOBALS: &str = include_str!("./globals.ts");

const FRAMEWORK_HEADER: &str =
    "// This file has been generated by Tauri Specta. Do not edit this file manually.\n";

const AS_RESULT_IMPL: &str =
    "async function typedError<T, E>(result: Promise<T>): Promise<{ Ok: T } | { Error: E }> {
  return await result as any; // TODO
}\n";

const MAKE_EVENT_IMPL: &str = "function makeEvent<T>() {
    return (e: T) => {}; // TODO
}\n";

impl LanguageExt for specta_typescript::Typescript {
    type Error = specta_typescript::Error;

    fn render(&self, cfg: &ExportContext) -> Result<String, Self::Error> {
        // let dependant_types = cfg
        //     .types
        //     .into_sorted_iter()
        //     .map(|ndt| primitives::export(&self, &cfg.types, &ndt))
        //     .collect::<Result<Vec<_>, _>>()
        //     .map(|v| v.join("\n"))?;

        // js_ts::render_all_parts::<Self>(
        //     cfg,
        //     &dependant_types,
        //     GLOBALS,
        //     &self.header,
        //     render_commands(self, cfg)?,
        //     render_events(self, cfg)?,
        //     true,
        // )

        // TODO:
        //  - JSDoc support
        //  - Move to `export_to` so we can get multi-file exporting. That will break stuff heaps lol.
        //  - Allow `asResult` to be replaced by userspace impl. Assert type for it though in the codegen?
        //

        let enabled_commands = !cfg.commands.is_empty();
        let enabled_events = !cfg.events.is_empty();

        let mut header = FRAMEWORK_HEADER.to_string();

        if enabled_commands {
            header.push_str("import { invoke as __TAURI_INVOKE } from '@tauri-apps/api/core';\n");
        }

        if enabled_commands {
            header.push_str("\nexport const commands = {");
            for command in cfg.commands.iter() {
                // TODO: Handle JSDoc comments + deprecated
                // TODO: Maybe move this back into Specta as a primitive

                header.push_str("\n\t");
                header.push_str(&command.name().to_lower_camel_case());
                header.push_str(": (");
                // TODO: Arguments
                header.push_str(") => ");

                let command_raw_name = cfg
                    .plugin_name
                    .as_ref()
                    .map(|n| apply_as_prefix(n, command.name(), ItemType::Command))
                    .unwrap_or_else(|| command.name().to_string()); // TODO: Avoid allocs on this statement?
                if cfg.error_handling == ErrorHandlingMode::Result
                    && let Some(r) = command.result()
                {
                    // &
                    // TODO:
                    //  - Error/result type
                    //  - Command name
                    //  - Arguments
                    header.push_str("typedError<");
                    header.push_str(
                        "any", // primitives::export(&ts, &types, command.result())?
                              //     .as_ref()
                              //     .map(|v| &*v)
                              //     .unwrap_or("void"),
                    );
                    header.push_str(", ");
                    header.push_str("any"); // TODO
                    header.push_str(">(__TAURI_INVOKE(\"");
                    header.push_str(&command_raw_name); // TODO: Properly escape incase it contains `"`
                    header.push_str("\"))");
                } else {
                    // TODO:
                    //  - Result type
                    //  - Command name
                    //  - Arguments
                    header.push_str("__TAURI_INVOKE<");
                    header.push_str("any"); // TODDO
                    header.push_str(">(\"");
                    header.push_str(&command_raw_name); // TODO: Properly escape incase it contains `"`
                    header.push_str("\")");
                };

                header.push(',');
            }
            header.push_str("\n}\n");
        }

        if enabled_events {
            header.push_str("\nexport const events = {");
            for (name, event) in cfg.events.iter() {
                header.push_str("\n\t");
                header.push_str(&name.to_lower_camel_case());
                header.push_str(": makeEvent<");
                header.push_str("any"); // TODO
                header.push_str(">(),");
            }
            header.push_str("\n}\n");
        }

        for (key, value) in cfg.constants.iter() {
            header.push_str("\nexport const ");
            header.push_str(key); // TODO: Transform name???
            header.push_str(" = ");
            header.push_str(
                &serde_json::to_string_pretty(&value)
                    .expect("failed to serialize from `serde_json::Value`"),
            );

            // if as_const { // `if typescript_exporter`
            match &value {
                serde_json::Value::Null => {}
                serde_json::Value::Bool(_)
                | serde_json::Value::Number(_)
                | serde_json::Value::String(_)
                | serde_json::Value::Array(_)
                | serde_json::Value::Object(_) => header.push_str(" as const"),
            }

            header.push(';');
        }

        let mut result = Typescript::new()
            .framework_header(header)
            .export(cfg.types)?;

        // Runtime
        if enabled_commands || enabled_events {
            result.push_str("\n/* Tauri Specta runtime */\n");

            if enabled_commands {
                result.push_str(AS_RESULT_IMPL);
            }
            if enabled_events {
                result.push_str(MAKE_EVENT_IMPL);
            }
        }

        Ok(result)
    }
}

// fn render_commands(
//     ts: &Typescript,
//     cfg: &ExportContext,
// ) -> Result<String, specta_typescript::Error> {
//     let commands = cfg
//         .commands
//         .iter()
//         .map(|function| {
//             let arg_defs = function
//                 .args()
//                 .into_iter()
//                 .map(|(name, typ)| {
//                     primitives::inline(ts, &cfg.types, &typ)
//                         .map(|ty| format!("{}: {}", name.to_lower_camel_case(), ty))
//                 })
//                 .collect::<Result<Vec<_>, _>>()?;

//             let ret_type = js_ts::handle_result(function, &cfg.types, ts, cfg.error_handling)?;

//             let docs = {
//                 // let mut builder = js_doc::Builder::default();

//                 // if let Some(d) = &function.deprecated() {
//                 //     builder.push_deprecated(d);
//                 // }

//                 // if !function.docs().is_empty() {
//                 //     builder.extend(function.docs().split("\n"));
//                 // }

//                 // builder.build()
//                 format!("") // TODO
//             };
//             Ok(js_ts::function(
//                 &docs,
//                 &function.name().to_lower_camel_case(),
//                 &arg_defs,
//                 Some(&ret_type),
//                 &js_ts::command_body(&cfg.plugin_name, function, true, cfg.error_handling),
//             ))
//         })
//         .collect::<Result<Vec<_>, specta_typescript::Error>>()?
//         .join(",\n");

//     Ok(format! {
//         r#"
// export const commands = {{
// {commands}
// }}"#
//     })
// }

// fn render_events(ts: &Typescript, cfg: &ExportContext) -> Result<String, specta_typescript::Error> {
//     if cfg.events.is_empty() {
//         return Ok(Default::default());
//     }

//     let (events_types, events_map) =
//         js_ts::events_data(&cfg.events, ts, &cfg.plugin_name, &cfg.types)?;

//     let events_types = events_types.join(",\n");

//     Ok(format! {
//         r#"
// export const events = __makeEvents__<{{
// {events_types}
// }}>({{
// {events_map}
// }})"#
//     })
// }
