use std::borrow::Cow;

use crate::{ErrorHandlingMode, ExportContext, ItemType, LanguageExt, apply_as_prefix};
use heck::ToLowerCamelCase;
use specta::datatype::{Field, Function, FunctionReturnType, Struct};
use specta_typescript::{self as ts, JSDoc, Typescript, primitives};

const GLOBALS: &str = include_str!("./globals.ts");

const FRAMEWORK_HEADER: &str =
    "// This file has been generated by Tauri Specta. Do not edit this file manually.\n";

const AS_RESULT_IMPL: &str =
    "async function typedError<T, E>(result: Promise<T>): Promise<{ Ok: T } | { Error: E }> {
  return await result as any; // TODO
}";

const MAKE_EVENT_IMPL: &str = "function makeEvent<T>() {
    return (e: T) => {}; // TODO
}";

impl LanguageExt for specta_typescript::Typescript {
    type Error = specta_typescript::Error;

    fn render(&mut self, cfg: &ExportContext) -> Result<String, Self::Error> {
        // let dependant_types = cfg
        //     .types
        //     .into_sorted_iter()
        //     .map(|ndt| primitives::export(&self, &cfg.types, &ndt))
        //     .collect::<Result<Vec<_>, _>>()
        //     .map(|v| v.join("\n"))?;

        // js_ts::render_all_parts::<Self>(
        //     cfg,
        //     &dependant_types,
        //     GLOBALS,
        //     &self.header,
        //     render_commands(self, cfg)?,
        //     render_events(self, cfg)?,
        //     true,
        // )

        // TODO:
        //  - JSDoc support
        //  - Move to `export_to` so we can get multi-file exporting. That will break stuff heaps lol.
        //  - Allow `asResult` to be replaced by userspace impl. Assert type for it though in the codegen?
        //

        let enabled_commands = !cfg.commands.is_empty();
        let enabled_events = !cfg.events.is_empty();

        let prelude = {
            let mut prelude = FRAMEWORK_HEADER.to_string();

            // TODO: Only include the `Channel` import if it's used

            prelude
        };

        let runtime = {
            let mut runtime = String::new();

            if enabled_commands {
                runtime
                    .push_str("import { invoke as __TAURI_INVOKE } from '@tauri-apps/api/core';\n");
                runtime.push('\n');
            }

            for command in cfg.commands {
                if let Some(result) = command.result() {
                    match result {
                        FunctionReturnType::Value(dt) => {
                            // TODO: We need to make an import
                        }
                        FunctionReturnType::Result(dt_ok, dt_err) => {
                            // TODO: We need to make an import
                        }
                    }
                }
            }

            // Commands
            if enabled_commands {
                let mut s = Struct::named();
                for command in cfg.commands {
                    let command_raw_name = cfg
                        .plugin_name
                        .as_ref()
                        .map(|n| apply_as_prefix(n, command.name(), ItemType::Command))
                        .unwrap_or_else(|| command.name().to_string()); // TODO: Avoid allocs on this statement?

                    // TODO: Handle command arguments
                    let arguments = "";

                    let body = if cfg.error_handling == ErrorHandlingMode::Result
                        && let Some(FunctionReturnType::Result(dt_ok, dt_err)) = command.result()
                    {
                        format!(
                            "typedError<{}, {}>(__TAURI_INVOKE(\"{}\", {}))",
                            primitives::reference(self, cfg.types, dt_ok)?,
                            primitives::reference(self, cfg.types, dt_err)?,
                            command_raw_name, // TODO: Properly escape incase it contains `"`
                            ""                // TODO: Proxy command args through
                        )
                    } else {
                        format!(
                            "__TAURI_INVOKE<{}>(\"{}\", {})",
                            match command.result() {
                                Some(
                                    FunctionReturnType::Value(dt)
                                    | FunctionReturnType::Result(dt, _),
                                ) => Cow::Owned(primitives::reference(self, cfg.types, dt)?),
                                None => Cow::Borrowed("void"),
                            },
                            command_raw_name, // TODO: Properly escape incase it contains `"`
                            ""                // TODO: Proxy command args through
                        )
                    };

                    let mut field =
                        Field::new(self.define(format!("({arguments}) => {body}")).into());
                    field.set_deprecated(command.deprecated().cloned());
                    field.set_docs(command.docs().clone());
                    s = s.field(command.name().to_lower_camel_case(), field);
                }

                runtime.push_str("export const commands = ");
                runtime.push_str(&primitives::inline(self, cfg.types, &s.build())?); // TODO: JSDoc support
            }

            // Events
            // TODO

            // Constants
            // TODO

            // Runtime
            if enabled_commands || enabled_events {
                runtime.push_str("\n\n/* Tauri Specta runtime */\n");

                if enabled_commands {
                    runtime.push_str(AS_RESULT_IMPL);
                    runtime.push_str("\n\n");
                }
                if enabled_events {
                    runtime.push_str(MAKE_EVENT_IMPL);
                }
            }

            runtime
        };

        // if enabled_events {
        //     header.push_str("\nexport const events = {");
        //     for (name, event) in cfg.events.iter() {
        //         header.push_str("\n\t");
        //         header.push_str(&name.to_lower_camel_case());
        //         header.push_str(": makeEvent<");
        //         header.push_str("any"); // TODO
        //         header.push_str(">(),");
        //     }
        //     header.push_str("\n}\n");
        // }

        // for (key, value) in cfg.constants.iter() {
        //     header.push_str("\nexport const ");
        //     header.push_str(key); // TODO: Transform name???
        //     header.push_str(" = ");
        //     header.push_str(
        //         &serde_json::to_string_pretty(&value)
        //             .expect("failed to serialize from `serde_json::Value`"),
        //     );

        //     // if as_const { // `if typescript_exporter`
        //     match &value {
        //         serde_json::Value::Null => {}
        //         serde_json::Value::Bool(_)
        //         | serde_json::Value::Number(_)
        //         | serde_json::Value::String(_)
        //         | serde_json::Value::Array(_)
        //         | serde_json::Value::Object(_) => header.push_str(" as const"),
        //     }

        //     header.push(';');
        // }

        Typescript::new()
            .framework_prelude(prelude.clone())
            .framework_runtime(runtime.clone())
            // TODO: These would be configured in userspace
            .layout(specta_typescript::Layout::Files)
            .export_to("../src/testing", cfg.types)
            .unwrap();

        Typescript::new()
            .framework_prelude(prelude.clone())
            .framework_runtime(runtime.clone())
            // TODO: These would be configured in userspace
            .layout(specta_typescript::Layout::Namespaces)
            .export_to("../src/namespaces.ts", cfg.types)
            .unwrap();

        Typescript::new()
            .framework_prelude(prelude)
            .framework_runtime(runtime)
            .export(cfg.types)
    }
}

// fn render_commands(
//     ts: &Typescript,
//     cfg: &ExportContext,
// ) -> Result<String, specta_typescript::Error> {
//     let commands = cfg
//         .commands
//         .iter()
//         .map(|function| {
//             let arg_defs = function
//                 .args()
//                 .into_iter()
//                 .map(|(name, typ)| {
//                     primitives::inline(ts, &cfg.types, &typ)
//                         .map(|ty| format!("{}: {}", name.to_lower_camel_case(), ty))
//                 })
//                 .collect::<Result<Vec<_>, _>>()?;

//             let ret_type = js_ts::handle_result(function, &cfg.types, ts, cfg.error_handling)?;

//             let docs = {
//                 // let mut builder = js_doc::Builder::default();

//                 // if let Some(d) = &function.deprecated() {
//                 //     builder.push_deprecated(d);
//                 // }

//                 // if !function.docs().is_empty() {
//                 //     builder.extend(function.docs().split("\n"));
//                 // }

//                 // builder.build()
//                 format!("") // TODO
//             };
//             Ok(js_ts::function(
//                 &docs,
//                 &function.name().to_lower_camel_case(),
//                 &arg_defs,
//                 Some(&ret_type),
//                 &js_ts::command_body(&cfg.plugin_name, function, true, cfg.error_handling),
//             ))
//         })
//         .collect::<Result<Vec<_>, specta_typescript::Error>>()?
//         .join(",\n");

//     Ok(format! {
//         r#"
// export const commands = {{
// {commands}
// }}"#
//     })
// }

// fn render_events(ts: &Typescript, cfg: &ExportContext) -> Result<String, specta_typescript::Error> {
//     if cfg.events.is_empty() {
//         return Ok(Default::default());
//     }

//     let (events_types, events_map) =
//         js_ts::events_data(&cfg.events, ts, &cfg.plugin_name, &cfg.types)?;

//     let events_types = events_types.join(",\n");

//     Ok(format! {
//         r#"
// export const events = __makeEvents__<{{
// {events_types}
// }}>({{
// {events_map}
// }})"#
//     })
// }
