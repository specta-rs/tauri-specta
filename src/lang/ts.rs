use crate::{
    ErrorHandlingMode, ExportContext, ItemType, LanguageExt, apply_as_prefix, lang::js_ts,
};
use heck::ToLowerCamelCase;
use specta::datatype::{Function, FunctionReturnType};
use specta_typescript::{self as ts, Typescript, primitives};

const GLOBALS: &str = include_str!("./globals.ts");

const FRAMEWORK_HEADER: &str = "// This file has been generated by Tauri Specta. DO NOT EDIT.
import { invoke as __TAURI_INVOKE } from '@tauri-apps/api/core';";

const AS_RESULT_IMPL: &str =
    "async function typedError<T, E>(result: Promise<T>): Promise<{ Ok: T } | { Error: E }> {
  return await result as any; // TODO
}";

impl LanguageExt for specta_typescript::Typescript {
    type Error = specta_typescript::Error;

    fn render(&self, cfg: &ExportContext) -> Result<String, Self::Error> {
        // let dependant_types = cfg
        //     .types
        //     .into_sorted_iter()
        //     .map(|ndt| primitives::export(&self, &cfg.types, &ndt))
        //     .collect::<Result<Vec<_>, _>>()
        //     .map(|v| v.join("\n"))?;

        // js_ts::render_all_parts::<Self>(
        //     cfg,
        //     &dependant_types,
        //     GLOBALS,
        //     &self.header,
        //     render_commands(self, cfg)?,
        //     render_events(self, cfg)?,
        //     true,
        // )

        // TODO:
        //  - JSDoc support
        //  - Support everything
        //  - Move to `export_to` so we can get multi-file exporting. That will break stuff heaps lol.
        //  - Allow `asResult` to be replaced by userspace impl. Assert type for it though in the codegen?
        //
        let ts = Typescript::new()
            .framework_header(FRAMEWORK_HEADER)
            .header("// eslint-disable"); // TODO: Remove this

        let mut result = ts.export(cfg.types)?;

        // Runtime
        result.push('\n');
        result.push_str(AS_RESULT_IMPL);
        result.push('\n');

        // Commands
        result.push_str("\nexport const commands = {");
        for command in cfg.commands.iter() {
            // TODO: Handle JSDoc comments + deprecated
            // TODO: Maybe move this back into Specta as a primitive

            result.push_str("\n\t");
            result.push_str(&command.name().to_lower_camel_case());
            result.push_str(": (");
            // TODO: Arguments
            result.push_str(") => ");

            let command_raw_name = cfg
                .plugin_name
                .as_ref()
                .map(|n| apply_as_prefix(n, command.name(), ItemType::Command))
                .unwrap_or_else(|| command.name().to_string()); // TODO: Avoid allocs on this statement?
            if cfg.error_handling == ErrorHandlingMode::Result
                && let Some(r) = command.result()
            {
                // &
                // TODO:
                //  - Error/result type
                //  - Command name
                //  - Arguments
                result.push_str("typedError<");
                result.push_str(
                    "any", // primitives::export(&ts, &types, command.result())?
                          //     .as_ref()
                          //     .map(|v| &*v)
                          //     .unwrap_or("void"),
                );
                result.push_str(", ");
                result.push_str("any"); // TODO
                result.push_str(">(__TAURI_INVOKE(\"");
                result.push_str(&command_raw_name); // TODO: Properly escape incase it contains `"`
                result.push_str("\"))");
            } else {
                // TODO:
                //  - Result type
                //  - Command name
                //  - Arguments
                result.push_str("__TAURI_INVOKE<");
                result.push_str("any"); // TODDO
                result.push_str(">(\"");
                result.push_str(&command_raw_name); // TODO: Properly escape incase it contains `"`
                result.push_str("\")");
            };

            result.push(',');
        }
        result.push_str("\n}");

        // TODO: Commands
        // TODO: Events
        // TODO: Constants

        Ok(result)
    }
}

// fn render_commands(
//     ts: &Typescript,
//     cfg: &ExportContext,
// ) -> Result<String, specta_typescript::Error> {
//     let commands = cfg
//         .commands
//         .iter()
//         .map(|function| {
//             let arg_defs = function
//                 .args()
//                 .into_iter()
//                 .map(|(name, typ)| {
//                     primitives::inline(ts, &cfg.types, &typ)
//                         .map(|ty| format!("{}: {}", name.to_lower_camel_case(), ty))
//                 })
//                 .collect::<Result<Vec<_>, _>>()?;

//             let ret_type = js_ts::handle_result(function, &cfg.types, ts, cfg.error_handling)?;

//             let docs = {
//                 // let mut builder = js_doc::Builder::default();

//                 // if let Some(d) = &function.deprecated() {
//                 //     builder.push_deprecated(d);
//                 // }

//                 // if !function.docs().is_empty() {
//                 //     builder.extend(function.docs().split("\n"));
//                 // }

//                 // builder.build()
//                 format!("") // TODO
//             };
//             Ok(js_ts::function(
//                 &docs,
//                 &function.name().to_lower_camel_case(),
//                 &arg_defs,
//                 Some(&ret_type),
//                 &js_ts::command_body(&cfg.plugin_name, function, true, cfg.error_handling),
//             ))
//         })
//         .collect::<Result<Vec<_>, specta_typescript::Error>>()?
//         .join(",\n");

//     Ok(format! {
//         r#"
// export const commands = {{
// {commands}
// }}"#
//     })
// }

// fn render_events(ts: &Typescript, cfg: &ExportContext) -> Result<String, specta_typescript::Error> {
//     if cfg.events.is_empty() {
//         return Ok(Default::default());
//     }

//     let (events_types, events_map) =
//         js_ts::events_data(&cfg.events, ts, &cfg.plugin_name, &cfg.types)?;

//     let events_types = events_types.join(",\n");

//     Ok(format! {
//         r#"
// export const events = __makeEvents__<{{
// {events_types}
// }}>({{
// {events_map}
// }})"#
//     })
// }
