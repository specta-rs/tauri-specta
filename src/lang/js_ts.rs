use std::{borrow::Cow, path::Path};

use heck::ToLowerCamelCase;
use specta::datatype::{Field, FunctionReturnType, Struct};
use specta_typescript::{Error, Exporter, define, primitives};

use crate::{BuilderConfiguration, ErrorHandlingMode, LanguageExt};

const FRAMEWORK_HEADER: &str =
    "// This file has been generated by Tauri Specta. Do not edit this file manually.";

const TYPED_ERROR_IMPL_TS: &str = r#"async function typedError<T, E>(result: Promise<T>): Promise<{ status: "ok", data: T } | { status: "error", error: E }> {
    return await result as any; // TODO
}"#;

const TYPED_ERROR_IMPL_JS: &str = r#"async function typedError<T, E>(result: Promise<T>): Promise<{ status: "ok", data: T } | { status: "error", error: E }> {
    return await result as any; // TODO
}"#;

const MAKE_EVENT_IMPL_TS: &str = r#"function makeEvent<T>(name: string) {
    return (e: T) => {}; // TODO
}"#;

const MAKE_EVENT_IMPL_JS: &str = r#"function makeEvent<T>(name: string) {
    return (e: T) => {}; // TODO
}"#;

impl LanguageExt for specta_typescript::Typescript {
    type Error = specta_typescript::Error;

    fn export(self, cfg: &BuilderConfiguration, path: &Path) -> Result<(), Self::Error> {
        let exporter = Exporter::from(self);
        let (source, runtime) = build(
            &exporter,
            cfg,
            true,
            TYPED_ERROR_IMPL_TS,
            if !cfg.as_result_impl.is_empty() {
                &cfg.as_result_impl
            } else {
                MAKE_EVENT_IMPL_TS
            },
        )?;
        exporter
            .framework_prelude(FRAMEWORK_HEADER)
            .framework_runtime(move |types| construct(&source, types, &runtime))
            .export_to(path, &cfg.types)
    }
}

impl LanguageExt for specta_typescript::JSDoc {
    type Error = specta_typescript::Error;

    fn export(self, cfg: &BuilderConfiguration, path: &Path) -> Result<(), Self::Error> {
        let exporter = Exporter::from(self);
        let (source, runtime) = build(
            &exporter,
            cfg,
            false,
            TYPED_ERROR_IMPL_JS,
            if !cfg.as_result_impl.is_empty() {
                &cfg.as_result_impl
            } else {
                MAKE_EVENT_IMPL_JS
            },
        )?;
        exporter
            .framework_prelude(FRAMEWORK_HEADER)
            .framework_runtime(move |types| construct(&source, types, &runtime))
            .export_to(path, &cfg.types)
    }
}

fn build(
    exporter: &Exporter,
    cfg: &BuilderConfiguration,
    as_const: bool,
    typed_error_impl: &str,
    make_event_impl: &str,
) -> Result<(String, String), Error> {
    let enabled_commands = !cfg.commands.is_empty();
    let enabled_events = !cfg.events.is_empty();

    let source = {
        let mut source = String::new();

        let is_channel_used = true;
        // builder
        //     .commands
        //     .iter()
        //     .flat_map(|v| {
        //         [
        //             v.args(),
        //             match v.result() {
        //                 Some(_) => todo!(),
        //                 None => todo!(),
        //             },
        //         ]
        //     })
        //     .any(|(_, arg)| match arg {
        //         DataType::Reference(Reference::Named(r)) => r
        //             .get(&builder.types)
        //             .map(|dt| {
        //                 dt.name() == "TAURI_CHANNEL" && dt.module_path().starts_with("tauri::")
        //             })
        //             .unwrap_or_default(),
        //         _ => false,
        //     });

        // TODO: This only works if no functions use `Channel` which isn't really desired.
        // TODO: I wonder if this error should be in Specta???
        // TODO: Test this works
        // if !is_channel_used
        //     && let Some(ndt) = builder.types.into_unsorted_iter().find(|ndt| {
        //         ndt.name() == "TAURI_CHANNEL" && ndt.module_path().starts_with("tauri::")
        //     })
        // {
        //     return Err(Error::Framework(
        //         format!("Detected invalid usage of `tauri::ipc::Channel` in type '{}' defined in {} which is not valid! It can only be an argument or result of a Tauri command.", ndt.name(), ndt.module_path()).into()
        //     ));
        // }

        if enabled_commands || is_channel_used {
            source.push_str("import { ");

            for (i, import) in [
                enabled_commands.then_some("invoke as __TAURI_INVOKE"),
                is_channel_used.then_some("Channel"),
            ]
            .iter()
            .flatten()
            .enumerate()
            {
                source.push_str(import);
                if i < 1 {
                    source.push_str(", ");
                }
            }

            source.push_str(" } from '@tauri-apps/api/core';\n");
        }

        // Commands
        if enabled_commands {
            let mut s = Struct::named();
            for command in &cfg.commands {
                let command_name_escaped = serde_json::to_string(
                    &cfg.plugin_name
                        .map(|plugin_name| {
                            format!("plugin|{plugin_name}|{}", command.name()).into()
                        })
                        .unwrap_or_else(|| command.name().clone()),
                )
                .expect("failed to serialize string");

                let arguments = command
                    .args()
                    .iter()
                    .map(|(name, dt)| {
                        Ok(format!(
                            "{}: {}",
                            name.to_lower_camel_case(),
                            primitives::reference(exporter, &cfg.types, dt)?
                        ))
                    })
                    .collect::<Result<Vec<_>, Error>>()?
                    .join(", ");

                let arguments_invoke_obj = if command.args().is_empty() {
                    Default::default()
                } else {
                    format!(
                        ", {{ {} }}",
                        command
                            .args()
                            .iter()
                            .map(|(name, _)| name.to_lower_camel_case())
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                };

                let body = if cfg.error_handling == ErrorHandlingMode::Result
                    && let Some(FunctionReturnType::Result(dt_ok, dt_err)) = command.result()
                {
                    format!(
                        "typedError<{}, {}>(__TAURI_INVOKE({command_name_escaped}{arguments_invoke_obj}))",
                        primitives::reference(exporter, &cfg.types, dt_ok)?,
                        primitives::reference(exporter, &cfg.types, dt_err)?,
                    )
                } else {
                    format!(
                        "__TAURI_INVOKE<{}>({command_name_escaped}{arguments_invoke_obj})",
                        match command.result() {
                            Some(
                                FunctionReturnType::Value(dt) | FunctionReturnType::Result(dt, _),
                            ) => Cow::Owned(primitives::reference(exporter, &cfg.types, dt)?),
                            None => Cow::Borrowed("void"),
                        },
                    )
                };

                let mut field = Field::new(define(format!("({arguments}) => {body}")).into());
                field.set_deprecated(command.deprecated().cloned());
                field.set_docs(command.docs().clone());
                s = s.field(command.name().to_lower_camel_case(), field);
            }

            source.push_str("\n/* Commands */");
            source.push_str("\nexport const commands = ");
            source.push_str(&primitives::inline(exporter, &cfg.types, &s.build())?); // TODO: JSDoc support
            source.push_str(";\n");
        }

        // Events
        if enabled_events {
            let mut s = Struct::named();
            for (name, (_, dt)) in &cfg.events {
                let event_name_escaped = serde_json::to_string(
                    &cfg.plugin_name
                        .map(|plugin_name| format!("plugin:{plugin_name}:{name}"))
                        .unwrap_or_else(|| name.to_string()),
                )
                .expect("failed to serialize string");

                let field = Field::new(
                    define(format!(
                        "makeEvent<{}>({event_name_escaped})",
                        primitives::reference(exporter, &cfg.types, dt)?
                    ))
                    .into(),
                );
                s = s.field(name.to_lower_camel_case(), field);
            }

            source.push_str("\n/* Events */");
            source.push_str("\nexport const events = ");
            source.push_str(&primitives::inline(exporter, &cfg.types, &s.build())?); // TODO: JSDoc support
            source.push_str(";\n");
        }

        // Constants
        if !cfg.constants.is_empty() {
            source.push_str("\n/* Constants */");

            let mut constants = cfg.constants.iter().collect::<Vec<_>>();
            constants.sort_by(|(a, _), (b, _)| a.cmp(b));
            for (i, (name, value)) in constants.iter().enumerate() {
                let mut as_constt = None;
                // `as const` isn't supported in JS so are conditional on that.
                if as_const {
                    match &value {
                        serde_json::Value::Null => {}
                        serde_json::Value::Bool(_)
                        | serde_json::Value::Number(_)
                        | serde_json::Value::String(_)
                        | serde_json::Value::Array(_)
                        | serde_json::Value::Object(_) => as_constt = Some(" as const"),
                    }
                }

                // TODO: Don't use `format!`
                source.push_str(&format!(
                    "\nexport const {name} = {}{};\n",
                    serde_json::to_string(&value)
                        .expect("failed to serialize from `serde_json::Value`"),
                    as_constt.unwrap_or("")
                ));
            }
        }

        source
    };

    let runtime = {
        let mut runtime = String::new();

        // Runtime
        if enabled_commands || enabled_events {
            runtime.push_str("\n/* Tauri Specta runtime */\n");

            if enabled_commands {
                if cfg.as_result_impl.is_empty() {
                    runtime.push_str(typed_error_impl);
                } else {
                    runtime.push_str(&cfg.as_result_impl);
                }
                runtime.push('\n');
                if enabled_events {
                    runtime.push('\n');
                }
            }
            if enabled_events {
                runtime.push_str(make_event_impl);
                runtime.push('\n');
            }
        }

        runtime
    };

    Ok((source, runtime))
}

fn construct(prefix: &str, types: Cow<'static, str>, suffix: &str) -> Cow<'static, str> {
    let mut out = prefix.to_string();

    // User types
    if !types.is_empty() {
        out.push_str("\n/* Types */");
        out.push_str(&types);
    }

    // Runtime
    out.push_str(suffix);

    Cow::Owned(out)
}
