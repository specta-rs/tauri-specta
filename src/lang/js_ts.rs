use std::{borrow::Cow, path::Path};

use heck::ToLowerCamelCase;
use specta::datatype::{DataType, Field, FunctionReturnType, Reference, Struct};
use specta_typescript::{Error, Exporter, define, primitives};

use crate::{BuilderConfiguration, ErrorHandlingMode, LanguageExt};

const FRAMEWORK_HEADER: &str =
    "// This file has been generated by Tauri Specta. Do not edit this file manually.";

const AS_RESULT_IMPL: &str =
    "async function typedError<T, E>(result: Promise<T>): Promise<{ Ok: T } | { Error: E }> {
  return await result as any; // TODO
}";

const MAKE_EVENT_IMPL: &str = "function makeEvent<T>() {
    return (e: T) => {}; // TODO
}";

impl LanguageExt for specta_typescript::Typescript {
    type Error = specta_typescript::Error;

    fn export(self, cfg: &BuilderConfiguration, path: &Path) -> Result<(), Self::Error> {
        let exporter = Exporter::from(self);
        let (source, runtime) = build(&exporter, cfg, true)?;
        exporter
            .framework_prelude(FRAMEWORK_HEADER)
            .framework_runtime(move |types| construct(&source, types, &runtime))
            .export_to(path, &cfg.types)
    }
}

impl LanguageExt for specta_typescript::JSDoc {
    type Error = specta_typescript::Error;

    fn export(self, cfg: &BuilderConfiguration, path: &Path) -> Result<(), Self::Error> {
        let exporter = Exporter::from(self);
        let (source, runtime) = build(&exporter, cfg, false)?;
        exporter
            .framework_prelude(FRAMEWORK_HEADER)
            .framework_runtime(move |types| construct(&source, types, &runtime))
            .export_to(path, &cfg.types)
    }
}

fn build(
    exporter: &Exporter,
    cfg: &BuilderConfiguration,
    as_const: bool,
) -> Result<(String, String), Error> {
    let enabled_commands = !cfg.commands.is_empty();
    let enabled_events = !cfg.events.is_empty();

    let source = {
        let mut source = String::new();

        let is_channel_used = true;
        // builder
        //     .commands
        //     .iter()
        //     .flat_map(|v| {
        //         [
        //             v.args(),
        //             match v.result() {
        //                 Some(_) => todo!(),
        //                 None => todo!(),
        //             },
        //         ]
        //     })
        //     .any(|(_, arg)| match arg {
        //         DataType::Reference(Reference::Named(r)) => r
        //             .get(&builder.types)
        //             .map(|dt| {
        //                 dt.name() == "TAURI_CHANNEL" && dt.module_path().starts_with("tauri::")
        //             })
        //             .unwrap_or_default(),
        //         _ => false,
        //     });

        // TODO: This only works if no functions use `Channel` which isn't really desired.
        // TODO: I wonder if this error should be in Specta???
        // TODO: Test this works
        // if !is_channel_used
        //     && let Some(ndt) = builder.types.into_unsorted_iter().find(|ndt| {
        //         ndt.name() == "TAURI_CHANNEL" && ndt.module_path().starts_with("tauri::")
        //     })
        // {
        //     return Err(Error::Framework(
        //         format!("Detected invalid usage of `tauri::ipc::Channel` in type '{}' defined in {} which is not valid! It can only be an argument or result of a Tauri command.", ndt.name(), ndt.module_path()).into()
        //     ));
        // }

        if enabled_commands || is_channel_used {
            source.push_str("import { ");

            for (i, import) in [
                enabled_commands.then_some("invoke as __TAURI_INVOKE"),
                enabled_commands.then_some("Channel"),
            ]
            .iter()
            .flatten()
            .enumerate()
            {
                source.push_str(import);
                if i < 1 {
                    source.push_str(", ");
                }
            }

            source.push_str(" } from '@tauri-apps/api/core';\n");
        }

        // Commands
        if enabled_commands {
            let mut s = Struct::named();
            for command in &cfg.commands {
                let command_raw_name = cfg
                    .plugin_name
                    .map(|plugin_name| format!("plugin|{plugin_name}|{}", command.name()).into())
                    .unwrap_or_else(|| command.name().clone());

                // TODO: Handle command arguments
                let arguments = "";

                let body = if cfg.error_handling == ErrorHandlingMode::Result
                    && let Some(FunctionReturnType::Result(dt_ok, dt_err)) = command.result()
                {
                    format!(
                        "typedError<{}, {}>(__TAURI_INVOKE(\"{}\", {}))",
                        primitives::reference(exporter, &cfg.types, dt_ok)?,
                        primitives::reference(exporter, &cfg.types, dt_err)?,
                        command_raw_name, // TODO: Properly escape incase it contains `"`
                        ""                // TODO: Proxy command args through
                    )
                } else {
                    format!(
                        "__TAURI_INVOKE<{}>(\"{}\", {})",
                        match command.result() {
                            Some(
                                FunctionReturnType::Value(dt) | FunctionReturnType::Result(dt, _),
                            ) => Cow::Owned(primitives::reference(exporter, &cfg.types, dt)?),
                            None => Cow::Borrowed("void"),
                        },
                        command_raw_name, // TODO: Properly escape incase it contains `"`
                        ""                // TODO: Proxy command args through
                    )
                };

                let mut field = Field::new(define(format!("({arguments}) => {body}")).into());
                field.set_deprecated(command.deprecated().cloned());
                field.set_docs(command.docs().clone());
                s = s.field(command.name().to_lower_camel_case(), field);
            }

            source.push_str("\n/* Commands */");
            source.push_str("\nexport const commands = ");
            source.push_str(&primitives::inline(exporter, &cfg.types, &s.build())?); // TODO: JSDoc support
            source.push_str(";\n");
        }

        // Events
        if enabled_events {
            source.push_str("\n/* Events */");

            // TODO
        }

        // Constants
        if !cfg.constants.is_empty() {
            source.push_str("\n/* Constants */");

            let mut constants = cfg.constants.iter().collect::<Vec<_>>();
            constants.sort_by(|(a, _), (b, _)| a.cmp(b));
            for (i, (name, value)) in constants.iter().enumerate() {
                let mut as_constt = None;
                // `as const` isn't supported in JS so are conditional on that.
                if as_const {
                    match &value {
                        serde_json::Value::Null => {}
                        serde_json::Value::Bool(_)
                        | serde_json::Value::Number(_)
                        | serde_json::Value::String(_)
                        | serde_json::Value::Array(_)
                        | serde_json::Value::Object(_) => as_constt = Some(" as const"),
                    }
                }

                // TODO: Move to this?
                // NamedDataTypeBuilder::new(name, vec![], dt).build(&mut cfg.types);

                // TODO: Don't use `format!`
                source.push_str(&format!(
                    "\nexport const {name} = {}{};\n",
                    serde_json::to_string(&value)
                        .expect("failed to serialize from `serde_json::Value`"),
                    as_constt.unwrap_or("")
                ));
            }
        }

        source
    };

    let runtime = {
        let mut runtime = String::new();

        // Runtime
        if enabled_commands || enabled_events {
            runtime.push_str("\n/* Tauri Specta runtime */\n");

            if enabled_commands {
                if cfg.as_result_impl.is_empty() {
                    runtime.push_str(AS_RESULT_IMPL);
                } else {
                    runtime.push_str(&cfg.as_result_impl);
                }
                runtime.push_str("\n\n");
            }
            if enabled_events {
                runtime.push_str(MAKE_EVENT_IMPL);
            }
        }

        runtime
    };

    Ok((source, runtime))
}

fn construct(prefix: &str, types: Cow<'static, str>, suffix: &str) -> Cow<'static, str> {
    let mut out = prefix.to_string();

    // User types
    if !types.is_empty() {
        out.push_str("\n/* Types */");
        out.push_str(&types);
    }

    // Runtime
    out.push_str(suffix);

    Cow::Owned(out)
}
